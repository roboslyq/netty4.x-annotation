# Netty服务端启动

> 我觉得在看这个源码之前 ，必须要自己去了解一下netty的工作流程，线程模块等相关的基础知识是很有必要。关于这些基础知识网上的文章很多，在此我不会对这些知识进行过多的讲解。本章节主要是针对源码相关进行详细讲解。

## 一、DEMO源码

讲解服务端启动流程，我们需要一个入口。这个入口就是Netty自带的`example`模块里的`echo`部分。此部分代码虽然简单，但基本上创建一个服务端的流程在此均会涉及。所谓麻雀虽小，五脏俱全。

`EchoServer`部分代码如下：（非关键代码已经删除）

```java
package io.netty.example.echo;
public final class EchoServer {
    //定义端口
    static final int PORT = Integer.parseInt(System.getProperty("port", "8007"));
    
    public static void main(String[] args) throws Exception {
        // Configure the server.
        // 初始化用于Acceptor的主"线程池"以及用于I/O工作的从"线程池"；
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        //设置工作线程池
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        // 创建Handler
        final EchoServerHandler serverHandler = new EchoServerHandler();
        try {
            // 创建
            ServerBootstrap b = new ServerBootstrap(); //(1)
            b.group(bossGroup, workerGroup)
             .channel(NioServerSocketChannel.class)
             .option(ChannelOption.SO_BACKLOG, 100)
             .handler(new LoggingHandler(LogLevel.INFO))
             .childHandler(new ChannelInitializer<SocketChannel>() {
                 @Override
                 public void initChannel(SocketChannel ch) throws Exception {
                     ChannelPipeline p = ch.pipeline();
                     if (sslCtx != null) {
                         p.addLast(sslCtx.newHandler(ch.alloc()));
                     }
                     //p.addLast(new LoggingHandler(LogLevel.INFO));
                     p.addLast(serverHandler);
                 }
             });
            // Start the server.
            ChannelFuture f = b.bind(PORT).sync();
            // Wait until the server socket is closed.
            f.channel().closeFuture().sync();
        } finally {
            // Shut down all event loops to terminate all threads.
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}

```

### 1、创建NioEventLoopGroup

​	注释(1)处，这个服务端Reactor模型的实现。其中上面代码中的bossGroup就是主从Reactor模型中的主线程组,workerGroup就是从线程组。

 	> 1、在 new NioEventLoopGroup(1) 时，指定的数1是指线程组只有一个线程(即单线程)。因此netty很方便的实现不同的Reactor线程模型。此线程模型是针对IO相关，而不是具体的业务。
 	>
 	> - Reactor单线程模型 <只有一个线程组Group在工作，处理所有的IO相关事件>
 	>
 	>   ```java
 	>   ServerBootstrap b = new ServerBootstrap()
 	>   EventLoopGroup  group = new NioEventLoopGroup();
 	>   b.group(group,group);
 	>   ```
 	>
 	> - Reactor多线程模型 <有两个线程组再工作，但主线程组只有一个线程负责Accept事件，从线程组负责IO读写相关操作>
 	>
 	>   ServerBootstrap b = new ServerBootstrap()
 	>
 	>   EventLoopGroup  bossGroup = new NioEventLoopGroup(1);
 	>
 	>   EventLoopGroup  workerGroup = new NioEventLoopGroup();
 	>
 	>   b.group(bossGroup,workerGroup);
 	>
 	> - 主从线程模型 <有两个线程组再工作，主线程组和从线程组均是一个线程池>
 	>
 	>   ServerBootstrap b = new ServerBootstrap()
 	>
 	>   EventLoopGroup  bossGroup = new NioEventLoopGroup();
 	>
 	>   EventLoopGroup  workerGroup = new NioEventLoopGroup();
 	>
 	>   b.group(bossGroup,workerGroup);

#### 1.1 NioEventLoopGroup#executor初始化

在创建`NioEventLoopGroup`时<创建Reactor线程组>，就已经确定了具体的相应的线程实例`NioEventLoop`中的`executor`类型。

`NioEventLoop是在构造函数中完成的。`

```java
public NioEventLoopGroup() {
        this(0);
    }
 public NioEventLoopGroup(int nThreads) {
        this(nThreads, (Executor) null);
    }
  public NioEventLoopGroup(int nThreads, Executor executor) {
        this(nThreads, executor, SelectorProvider.provider());
    }
    public NioEventLoopGroup(
            int nThreads, Executor executor, final SelectorProvider selectorProvider) {
        this(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);
    }
 public NioEventLoopGroup(int nThreads, Executor executor, final SelectorProvider selectorProvider,
                             final SelectStrategyFactory selectStrategyFactory) {
        super(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());
    }
```

上述`NioEventLoopGroup`构造函数层层重载，最终会调用super类`MultithreadEventExecutorGroup`相关构造函数。

```java

//NioEventLoopGroup的 父类 MultithreadEventLoopGroup
protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) {
        super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);
    }
//MultithreadEventLoopGroup的父类MultithreadEventExecutorGroup
 protected MultithreadEventExecutorGroup(int nThreads, Executor executor, Object... args) {
        this(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);
    }
protected MultithreadEventExecutorGroup(int nThreads, Executor executor,
                                            EventExecutorChooserFactory chooserFactory, Object... args) {
        if (nThreads <= 0) {
            throw new IllegalArgumentException(String.format("nThreads: %d (expected: > 0)", nThreads));
        }
		// executor类型ThreadPerTaskExecutor
        if (executor == null) {
            executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());
        }
		// 用户传入了线程数为nThreads,则创建nThreads个数NioEventLoop线程
         children = new EventExecutor[nThreads];
        // 服务端启动时，对应的具体实现类为NioEventLoopGroup，初始化具体线程NioEventLoop
        for (int i = 0; i < nThreads; i ++) {
            boolean success = false;
            try {
                // 如果是NioEventLoopGroup，则进行NioEventLoopGroup.newChild()方法中。
                children[i] = newChild(executor, args);
                success = true;
            } catch (Exception e) {
                // TODO: Think about if this is a good exception type
                throw new IllegalStateException("failed to create a child event loop", e);
            } finally {
                if (!success) {
                    for (int j = 0; j < i; j ++) {
                        children[j].shutdownGracefully();
                    }

                    for (int j = 0; j < i; j ++) {
                        EventExecutor e = children[j];
                        try {
                            while (!e.isTerminated()) {
                                e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);
                            }
                        } catch (InterruptedException interrupted) {
                            // Let the caller handle the interruption.
                            Thread.currentThread().interrupt();
                            break;
                        }
                    }
                }
            }
        }
    ... 
        
     protected ThreadFactory newDefaultThreadFactory() {
        return new DefaultThreadFactory(getClass());
    }
```

`DefaultThreadFactory`

```java
 
@Override
    public Thread newThread(Runnable r) {
        //此处使用的是FastThreadLocalRunnable进行包装后的线程
        Thread t = newThread(FastThreadLocalRunnable.wrap(r), prefix + nextId.incrementAndGet());
        try {
            if (t.isDaemon() != daemon) {
                t.setDaemon(daemon);
            }

            if (t.getPriority() != priority) {
                t.setPriority(priority);
            }
        } catch (Exception ignored) {
            // Doesn't matter even if failed to set.
        }
        return t;
    }
```

因此最终的线程是`FastThreadLocalRunnable`.

```java
final class FastThreadLocalRunnable implements Runnable {
    private final Runnable runnable;

    private FastThreadLocalRunnable(Runnable runnable) {
        this.runnable = ObjectUtil.checkNotNull(runnable, "runnable");
    }

    @Override
    public void run() {
        try {
            runnable.run();
        } finally {
            FastThreadLocal.removeAll();
        }
    }

    static Runnable wrap(Runnable runnable) {
        return runnable instanceof FastThreadLocalRunnable ? runnable : new FastThreadLocalRunnable(runnable);
    }
}
```

#### 1.2 NioEventLoop初始化

`NioEventLoop`是具体干活的线程,由`NioEventLoopGroup`进行初始化并分配任务(调度)。

`NioEventLoopGroup`

```java

// 用户传入了线程数为nThreads,则创建nThreads个数NioEventLoop线程
         children = new EventExecutor[nThreads];
        // 服务端启动时，对应的具体实现类为NioEventLoopGroup，初始化具体线程NioEventLoop
        for (int i = 0; i < nThreads; i ++) {
            boolean success = false;
            try {
                // 如果是NioEventLoopGroup，则进行NioEventLoopGroup.newChild()方法中。
                children[i] = newChild(executor, args);
                success = true;
            } catch (Exception e) {
                // TODO: Think about if this is a good exception type
                throw new IllegalStateException("failed to create a child event loop", e);
            }
            ... ...

                
     /**
     * 实例化具体的NioEventLoop线程。
     * @param executor ThreadPerTaskExecutor
     * @param args args[0] = 在windows下为WindowsSelectorProvider
     *             args[1] = DefaultSelectStrategyFactory
     *             args[1] = RejectedExecutionHandler
     * @return
     * @throws Exception
     */
    @Override
    protected EventLoop newChild(Executor executor, Object... args) throws Exception {
//创建NioEventLoop实例
                return new NioEventLoop(this, executor, (SelectorProvider) args[0],
            ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2]);
    }          
```



`NioEventLoop`

```java
NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,
                 SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) {
        // 父类中指定了当前NioEventLoop对应的Executor
        super(parent, executor, false, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);
        if (selectorProvider == null) {
            throw new NullPointerException("selectorProvider");
        }
        if (strategy == null) {
            throw new NullPointerException("selectStrategy");
        }
        // 在Windows环境下为：WindowsselectorProvider
        provider = selectorProvider;
        //  创建 NIO Selector 对象。
        final SelectorTuple selectorTuple = openSelector();
        selector = selectorTuple.selector;
        // 未包装的 Selector 对象
        unwrappedSelector = selectorTuple.unwrappedSelector;
        selectStrategy = strategy;
    }
//NioEventLoop父类 SingleThreadEventLoop==============构造函数
    /**
     * 默认会被子类调用的构造器
     * @param parent
     * @param executor
     * @param addTaskWakesUp
     * @param maxPendingTasks
     * @param rejectedExecutionHandler
     */
    protected SingleThreadEventLoop(EventLoopGroup parent, Executor executor,
                                    boolean addTaskWakesUp, int maxPendingTasks,
                                    RejectedExecutionHandler rejectedExecutionHandler) {
        super(parent, executor, addTaskWakesUp, maxPendingTasks, rejectedExecutionHandler);
        tailTasks = newTaskQueue(maxPendingTasks);
    }


//SingleThreadEventLoop的父类 SingleThreadEventExecutor==============构造函数
    protected SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor,
                                        boolean addTaskWakesUp, int maxPendingTasks,
                                        RejectedExecutionHandler rejectedHandler) {
       // parent = NioEventLoopGroup
        super(parent);
        this.addTaskWakesUp = addTaskWakesUp;
        this.maxPendingTasks = Math.max(16, maxPendingTasks);
        // 构造executor
        this.executor = ThreadExecutorMap.apply(executor, this);
        taskQueue = newTaskQueue(this.maxPendingTasks);
        rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, "rejectedHandler");
    }
```

> 注意`NioEventLoop`中的executor是经过`ThreadExecutorMap.apply(executor, this);`包装的



### 2、创建ServerBootStrap

首先看`ServerBootStrap`构造函数

```java
    public ServerBootstrap() { }

```

默认是空的，所以不有做什么事件。

主要是通过链式调用配置完成相关初始化。

```java
ServerBootstrap b = new ServerBootstrap();  
//设置线程组
            b.group(bossGroup, workerGroup)
                //设置Channel类型
             .channel(NioServerSocketChannel.class)
                //设置可选参数项
             .option(ChannelOption.SO_BACKLOG, 100)
                //设置主线程的Handler(处理IO连接)
             .handler(new LoggingHandler(LogLevel.INFO))
                //设置从线程的Handler(处理IO读写)
             .childHandler(new ChannelInitializer<SocketChannel>() {
                 // 匿名对象，对ChannelPipeline进行初始化
                 @Override
                 public void initChannel(SocketChannel ch) throws Exception {
                     ChannelPipeline p = ch.pipeline();
                     if (sslCtx != null) {
                         p.addLast(sslCtx.newHandler(ch.alloc()));
                     }
                     //p.addLast(new LoggingHandler(LogLevel.INFO));
                     p.addLast(serverHandler);
                 }
             });
```

> 注意匿名对象`ChannelInitializer`在系统启动时不会被调用，因此也不会构建相应的ChannelPipeline。而是当有客户端发起连接时，会为每一个客户端创建不同channelPipeline实现，从而完成初始化。

### 3、服务启动绑定监听端口

关键代码只有一行： ` ChannelFuture f = b.bind(PORT).sync();` 最终会在`AbstractNioChannel#doRegister()`方法中,实现与JDK的`SelectionKey `对接。

```java
 public ChannelFuture bind(int inetPort) {
        return bind(new InetSocketAddress(inetPort));
    }

   public ChannelFuture bind(SocketAddress localAddress) {
        validate();
        return doBind(ObjectUtil.checkNotNull(localAddress, "localAddress"));
    }
private ChannelFuture doBind(final SocketAddress localAddress) {
        /*
         * 异步初始化并且注册: 绑定Channel与NioEventLoop
         */
        final ChannelFuture regFuture = initAndRegister();
        final Channel channel = regFuture.channel();
        if (regFuture.cause() != null) {
            return regFuture;
        }
        /*
         *异步注册完成之后进入端口绑定<异步注册不一定完成，此处不会阻塞>：
         */
        if (regFuture.isDone()) {
            // At this point we know that the registration was complete and successful.
            ChannelPromise promise = channel.newPromise();
            // 当注册已经成功时，我们进行端口绑定
            doBind0(regFuture, channel, localAddress, promise);
            return promise;
        } else {
            // 如果异步注册对应的 ChanelFuture 未完成，则调用 ChannelFuture#addListener(ChannelFutureListener) 方法，添加监听器，
            // 在注册完成后，进行回调执行 #doBind0(...) 方法的逻辑
            // Registration future is almost always fulfilled already, but just in case it's not.
            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
            regFuture.addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture future) throws Exception {
                    Throwable cause = future.cause();
                    if (cause != null) {
                        // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an
                        // IllegalStateException once we try to access the EventLoop of the Channel.
//                        注册失败，回调通知 promise 异常。
                        promise.setFailure(cause);
                    } else {
//                        注册成功，调用 Channel#bind(SocketAddress localAddress, ChannelPromise promise) 方法
//                        ，执行 Channel 的端口绑定逻辑
                        // Registration was successful, so set the correct executor to use.
                        // See https://github.com/netty/netty/issues/2586
                        promise.registered();
                        //完成端口绑定
                        doBind0(regFuture, channel, localAddress, promise);
                    }
                }
            });
            return promise;
        }
    }
```

#### 3.1 AbstractBootstrap#initAndRegister()

此方法完成Channel相关的初始化和注册(即将Channel注册到Reactor主线程组中，与具体的NioEventloop线程绑定)

```java
final ChannelFuture initAndRegister() {
        Channel channel = null;
        try {
            //channelFactory = ReflectiveChannelFactory: 通过反射实例化channel
            channel = channelFactory.newChannel();
            //初始化channel<配置相关配置>
            init(channel);
        } catch (Throwable t) {
            if (channel != null) {
                channel.unsafe().closeForcibly();
                return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
            }
            return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
        }
        /*
         * 注册 Channel 到 EventLoopGroup 中：即将Channel（NioServerSocketChannel）注册到			 *	Reactor主线程中。
         *  config.group() = EventLoopGroup ,具体实例为MultithreadEventLoopGroup
         *  config().group().registrer()  = MultithreadEventLoopGroup.registrer()
         */
        ChannelFuture regFuture = config().group().register(channel);
        if (regFuture.cause() != null) {
            if (channel.isRegistered()) {
                channel.close();
            } else {
                channel.unsafe().closeForcibly();
            }
        }

        // If we are here and the promise is not failed, it's one of the following cases:
        // 1) If we attempted registration from the event loop, the registration has been completed at this point.
        //    i.e. It's safe to attempt bind() or connect() now because the channel has been registered.
        // 2) If we attempted registration from the other thread, the registration request has been successfully
        //    added to the event loop's task queue for later execution.
        //    i.e. It's safe to attempt bind() or connect() now:
        //         because bind() or connect() will be executed *after* the scheduled registration task is executed
        //         because register(), bind(), and connect() are all bound to the same thread.

        return regFuture;
    }
```

#### 3.1.1 init(channel)

通过`NioEventLoopGroup`创建时设置的相关参数，对`Channel`相关信息进行初始化。

```java
 @Override
    void init(Channel channel) throws Exception {
        /* 即获取如下代码中的option()方法设置的对应参数：
         * ServerBootstrap b = new ServerBootstrap();
         *             b.group(bossGroup, workerGroup)
         *              .channel(NioServerSocketChannel.class)
         *              .option(ChannelOption.SO_BACKLOG, 100)
         */
        final Map<ChannelOption<?>, Object> options = options0();
        synchronized (options) {
            setChannelOptions(channel, options, logger);
        }
        /*
         * Channel设置的相关属性
         */
        final Map<AttributeKey<?>, Object> attrs = attrs0();
        synchronized (attrs) {
            for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) {
                @SuppressWarnings("unchecked")
                AttributeKey<Object> key = (AttributeKey<Object>) e.getKey();
                channel.attr(key).set(e.getValue());
            }
        }
        /*
         * channel = NioServerSocketChannel： 初始化channelPipeline
         * p = DefaultChannelPipeline <在父类AbstractChannel构造方法中完成初始化>
         */
        ChannelPipeline p = channel.pipeline();
        //设置相关属性
        final EventLoopGroup currentChildGroup = childGroup;
        final ChannelHandler currentChildHandler = childHandler;
        final Entry<ChannelOption<?>, Object>[] currentChildOptions;
        final Entry<AttributeKey<?>, Object>[] currentChildAttrs;
        synchronized (childOptions) {
            currentChildOptions = childOptions.entrySet().toArray(newOptionArray(0));
        }
        synchronized (childAttrs) {
            currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(0));
        }
        //构造channelPipeline链最后一个channelHandler，此链固定为：ServerBootstrapAcceptor。用户不用进行相关设置
        /* 假设用户使用方式如下：
         ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
             .channel(NioServerSocketChannel.class)
             .option(ChannelOption.SO_BACKLOG, 100)
             .handler(new LoggingHandler(LogLevel.INFO))
             .childHandler(new ChannelInitializer<SocketChannel>() {
                 @Override
                 public void initChannel(SocketChannel ch) throws Exception {
                     ChannelPipeline p = ch.pipeline();
                     if (sslCtx != null) {
                         p.addLast(sslCtx.newHandler(ch.alloc()));
                     }
                     p.addLast(new LoggingHandler(LogLevel.INFO));
                     p.addLast(serverHandler);
                 }
             });

          那么，在此时，p中已经可能存在3个ChannelHandler了
               p.addLast(sslCtx.newHandler(ch.alloc()));
               p.addLast(new LoggingHandler(LogLevel.INFO));
               p.addLast(serverHandler);
          那么，再调用一次下面方法后，结果为：
               p.addLast(sslCtx.newHandler(ch.alloc()));
               p.addLast(new LoggingHandler(LogLevel.INFO));
               p.addLast(serverHandler);
               pipeline.addLast(new ServerBootstrapAcceptor())

          DefaultChannelPipeline采用了链表方式保存上述结构关系。
         */

        p.addLast(new ChannelInitializer<Channel>() {
            @Override
            public void initChannel(final Channel ch) throws Exception {
                final ChannelPipeline pipeline = ch.pipeline();
                ChannelHandler handler = config.handler();
                if (handler != null) {
                    pipeline.addLast(handler);
                }
                //异步添加内置的连接处理Handler： ServerBootstrapAcceptor
                ch.eventLoop().execute(new Runnable() {
                    @Override
                    public void run() {
                        pipeline.addLast(new ServerBootstrapAcceptor(
                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                    }
                });
            }
        });
    }
```

#### 3.1.2 config().group().register(channel)

此方法完成具体的信息注册。

##### 3.1.2.1 `MultithreadEventLoopGroup`

```java
 @Override
    public ChannelFuture register(Channel channel) {
        // group.next() = NioEventLoop
        // NioEvnetLoop.register()= SingleThreadEventLoop.register()
        // 将Channel注册到Reactor主线程组中具体的EventLoop线程中去，此时已经建议Channel与EventLoop对应关系。
        return next().register(channel);
    }
```

##### 3.1.2.2 `SingleThreadEventLoop`

```java
@Override
    public ChannelFuture register(Channel channel) {
        return register(new DefaultChannelPromise(channel, this));
    }
/**
     * 异步注册Channel，通过netty自定义的Unsafe工具类
     * @param promise
     * @return
     */
    @Override
    public ChannelFuture register(final ChannelPromise promise) {
        ObjectUtil.checkNotNull(promise, "promise");
        // promise.channel() = NioServerSocketChannel
        promise.channel().unsafe().register(this, promise);
        return promise;
    }
```

##### 3.1.2.3 `AbstractChannel`

```java
 /**
         * 注册 Channel
         * @param eventLoop
         * @param promise
         */
        @Override
        public final void register(EventLoop eventLoop, final ChannelPromise promise) {
            if (eventLoop == null) {
                throw new NullPointerException("eventLoop");
            }
            if (isRegistered()) {
                promise.setFailure(new IllegalStateException("registered to an event loop already"));
                return;
            }
            if (!isCompatible(eventLoop)) {
                promise.setFailure(
                        new IllegalStateException("incompatible event loop type: " + eventLoop.getClass().getName()));
                return;
            }

            AbstractChannel.this.eventLoop = eventLoop;
            //正常情况为false<启动时，在主线程中>
            if (eventLoop.inEventLoop()) {
                register0(promise);
            } else {
                try {
                    //注册核心方法
                    eventLoop.execute(new Runnable() {
                        @Override
                        public void run() {
                            register0(promise);
                        }
                    });
                } catch (Throwable t) {
                    logger.warn(
                            "Force-closing a channel whose registration task was not accepted by an event loop: {}",
                            AbstractChannel.this, t);
                    closeForcibly();
                    closeFuture.setClosed();
                    safeSetFailure(promise, t);
                }
            }
        }


private void register0(ChannelPromise promise) {
            try {
                if (!promise.setUncancellable() || !ensureOpen(promise)) {
                    return;
                }
                boolean firstRegistration = neverRegistered;
                //注册: AbstractNioChannel
                doRegister();
                neverRegistered = false;
                registered = true;
                pipeline.invokeHandlerAddedIfNeeded();

                safeSetSuccess(promise);
                // pipeline发送Channel注册事件
                pipeline.fireChannelRegistered();
                if (isActive()) {
                    if (firstRegistration) {
                        pipeline.fireChannelActive();
                    } else if (config().isAutoRead()) {
                        beginRead();
                    }
                }
            } catch (Throwable t) {
                // Close the channel directly to avoid FD leak.
                closeForcibly();
                closeFuture.setClosed();
                safeSetFailure(promise, t);
            }
        }

```

##### 3.1.2.4 `AbstractNioChannel`

```java
 @Override
    protected void doRegister() throws Exception {
        // 注册完成标识:刚开始默认false,注册完成后修改为true
        boolean selected = false;
        for (;;) {
            try {
                //此处selectionKey为Channel的实例实例变量
                selectionKey = javaChannel() // 获取JDK中的SelectableChannel
                        .register(eventLoop().unwrappedSelector(), 0, this);
                return;
            } catch (CancelledKeyException e) {
                if (!selected) {
                    eventLoop().selectNow();
                    selected = true;
                } else {
                    throw e;
                }
            }
        }
    }
```

#### 3.2 AbstractBootstrap#doBind0()

在`3.1`节异步返回`ChannelFuture`时，会进入`doBind0()`相关方法。实现端口监听。

```java
 private static void doBind0(
            final ChannelFuture regFuture, final Channel channel,
            final SocketAddress localAddress, final ChannelPromise promise) {
        //调用 EventLoop 执行 Channel 的端口绑定逻辑。
        // 这个方法在channelRegistered()触发前被调用，以便用户可以在channelRegistered()去设置pipeline相关信息。
        // channel.eventLoop().execute() = AstractEventExecutor.safeExecute()
        channel.eventLoop().execute(new Runnable() {
            @Override
            public void run() {
                if (regFuture.isSuccess()) {
                    //绑定端口: AbstractChannel.bind(SocketAddress localAddress, ChannelPromise promise)
                    channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
                } else {
                    promise.setFailure(regFuture.cause());
                }
            }
        });
    }
```

##### 3.2.1 bind()

`AbstractChannel`

```java
  @Override
    public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) {
        /* pipeline = DefaultChannelPipeline*/
        return pipeline.bind(localAddress, promise);
    }
```

`DefaultChannelPipeline`

```java
 @Override
    public final ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) {
        /*
         * 1、tail = DefaultChannelPipeline$TailContext
         * 2、tail没有重写bind(localAddress, promise)，因此调用的是父类AbstractChannelHandlerContext#bind(localAddress, promise)，
         */
        return tail.bind(localAddress, promise);
    }
```

`DefaultChannelPipeline`的内部内`TailContext`的父类`AbstractChannelHandlerConetext`

`AbstractChannelHandlerContext`

```java
@Override
    public ChannelFuture bind(final SocketAddress localAddress, final ChannelPromise promise) {
        if (localAddress == null) {
            throw new NullPointerException("localAddress");
        }
        if (isNotValidPromise(promise, false)) {
            // cancelled
            return promise;
        }
        /*
         * ChannelPipeline相关实现,调用流程如下：
         *      DefaultChannelPipeline#TailConext<TailContext>
         *          --> AbstractChannelHandlerContext<LoggingHandler>
         *              -->DefaultChannelPipeline#HeadContext<HeadContext>
         *                  -->Unsafe.bind(localAddress, promise)
         *                      -->NioServerSocketChannel.doBind()
         */
        final AbstractChannelHandlerContext next = findContextOutbound(MASK_BIND);
        EventExecutor executor = next.executor();
        //如果是EventLoop(默认是NioEventLoop，所以此处为true)
        if (executor.inEventLoop()) {
            //直接调用
            next.invokeBind(localAddress, promise);
        } else {
            safeExecute(executor, new Runnable() {
                @Override
                public void run() {
                    next.invokeBind(localAddress, promise);
                }
            }, promise, null);
        }
        return promise;
    }
```

这里方法调用有点绕，大概栈过程如下：

>  * DefaultChannelPipeline#TailConext<TailContext>
>          *      --> AbstractChannelHandlerContext<LoggingHandler>
>                    *      -->DefaultChannelPipeline#HeadContext<HeadContext>
>                              *      -->Unsafe.bind(localAddress, promise)
>                                        *                      -->NioServerSocketChannel.doBind()

经过`ChannelPipeline#tail`开始，最终会进入到`ChannelPipeline#HeadContext`，其中`HeadContext`会调用`Unsafe`完成`JDK NioServerSocket`监听。从而完成Netty与JDK对接。

`HeadContext`

```java
    /**
         * 绑定端口最终入口，因为当前ChannelHandler为Head(最后一个Handler)
         * @param ctx           the {@link ChannelHandlerContext} for which the bind operation is made
         * @param localAddress  the {@link SocketAddress} to which it should bound
         * @param promise       the {@link ChannelPromise} to notify once the operation completes
         */
        @Override
        public void bind(
                ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) {
            unsafe.bind(localAddress, promise);
        }
```

`Unsafe`

```java
 @Override
        public final void bind(final SocketAddress localAddress, final ChannelPromise promise) {
            // 判断是否在 EventLoop 的线程中。
            assertEventLoop();
            if (!promise.setUncancellable() || !ensureOpen(promise)) {
                return;
            }

            // See: https://github.com/netty/netty/issues/576
            if (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &&
                localAddress instanceof InetSocketAddress &&
                !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &&
                !PlatformDependent.isWindows() && !PlatformDependent.maybeSuperUser()) {
            }
            // 记录 Channel 是否激活
            // NioServerSocketChannel 的 #isActive() 的方法实现，判断 ServerSocketChannel 是否绑定端口。
            // 此时，一般返回的是 false
            boolean wasActive = isActive();
            try {
                //绑定 Channel 的端口
                doBind(localAddress);
            } catch (Throwable t) {
                safeSetFailure(promise, t);
                closeIfClosed();
                return;
            }
            // 若 Channel 是新激活的，触发通知 Channel 已激活的事件。
            if (!wasActive && isActive()) {
                //调用 #invokeLater(Runnable task) 方法，提交任务==> channel的Active事件被触发
                invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        // 触发 Channel 激活的事件===>核心方法<在HeadContext中会调用Unsafe#beginRead方法>
                        pipeline.fireChannelActive();
                    }
                });
            }
            // 回调通知 promise 执行成功
            safeSetSuccess(promise);
        }
```

`NioServerSocketChannel`

```java
    @Override
    protected void doBind(SocketAddress localAddress) throws Exception {
        if (PlatformDependent.javaVersion() >= 7) {
            // javaChannel() = ServerSocketChannelImpl
            javaChannel().bind(localAddress, config.getBacklog());
        } else {
            javaChannel().socket().bind(localAddress, config.getBacklog());
        }
    }
```



#### 3.3 监听Acceptor事件

注意在`3.1.2.3`节中有一段registory代码：

```java
 AbstractChannel.this.eventLoop = eventLoop;
            //正常情况为false<启动时，在主线程中>
            if (eventLoop.inEventLoop()) {
                register0(promise);
            } else {
                try {
                    //注册核心方法
                    eventLoop.execute(new Runnable() {
                        @Override
                        public void run() {
                            register0(promise);
                        }
                    });
                }
```

我们注意到，真正的registry不是实时的，而是使用了`NioEventLoop`的任务队列异步实现。`NioEventLoop`是在其父类`SingleThreadEventLoop`中实现.

``SingleThreadEventLoop#execute(Runnable)` 

```java
/**
     * 运行指定的任务
     * @param task
     */
    @Override
    public void execute(Runnable task) {
        if (task == null) {
            throw new NullPointerException("task");
        }

        boolean inEventLoop = inEventLoop();
        //添加到任务队列
        addTask(task);
        if (!inEventLoop) {//通常为falset
            // 启动任务
            startThread();
            if (isShutdown()) {
                boolean reject = false;
                try {
                    if (removeTask(task)) {
                        reject = true;
                    }
                } catch (UnsupportedOperationException e) {
                  
                }
                if (reject) {
                    reject();
                }
            }
        }

        if (!addTaskWakesUp && wakesUpForTask(task)) {
            wakeup(inEventLoop);
        }
    }
```

`SingleThreadEventExecutor#startThread()`

```java
 private void startThread() {
        if (state == ST_NOT_STARTED) {
            if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) {
                boolean success = false;
                try {
                    //启动任务
                    doStartThread();
                    success = true;
                } finally {
                    if (!success) {
                        STATE_UPDATER.compareAndSet(this, ST_STARTED, ST_NOT_STARTED);
                    }
                }
            }
        }
    }
 /**
     * 启动线程，执行完已经在任务队列中的任务
     */
    private void doStartThread() {
        assert thread == null;
        executor.execute(new Runnable() {
            @Override
            public void run() {
                thread = Thread.currentThread();
                if (interrupted) {
                    thread.interrupt();
                }

                boolean success = false;
                updateLastExecutionTime();
                try {
                    //关键代码==========>
                    SingleThreadEventExecutor.this.run();
                    success = true;
                } catch (Throwable t) {
                    logger.warn("Unexpected exception from an event executor: ", t);
                } finally {
                    for (;;) {
                        int oldState = state;
                        if (oldState >= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(
                                SingleThreadEventExecutor.this, oldState, ST_SHUTTING_DOWN)) {
                            break;
                        }
                    }

                    // Check if confirmShutdown() was called at the end of the loop.
                    if (success && gracefulShutdownStartTime == 0) {
                        if (logger.isErrorEnabled()) {
                            logger.error("Buggy " + EventExecutor.class.getSimpleName() + " implementation; " +
                                    SingleThreadEventExecutor.class.getSimpleName() + ".confirmShutdown() must " +
                                    "be called before run() implementation terminates.");
                        }
                    }

                    try {
                        // Run all remaining tasks and shutdown hooks.
                        // 确保所有的任务已经执行完成，调用关闭钩子
                        for (;;) {
                            if (confirmShutdown()) {
                                break;
                            }
                        }
                    } finally {
                        try {
                            cleanup();
                        } finally {
                            FastThreadLocal.removeAll();
                            STATE_UPDATER.set(SingleThreadEventExecutor.this, ST_TERMINATED);
                            threadLock.countDown();
                            if (logger.isWarnEnabled() && !taskQueue.isEmpty()) {
                                logger.warn("An event executor terminated with " +
                                        "non-empty task queue (" + taskQueue.size() + ')');
                            }
                            terminationFuture.setSuccess(null);
                        }
                    }
                }
            }
        });
    }
```

> 在`1.2 NioEventLoop初始化`章节已经提到,`executor`是经过ThreadExecutorMap.apply(executor, this);`包装的,所以上面的 executor.execute(new Runnable() )是调用包装过之后的后executor.

此处`SingleThreadEventExecutor.this.run()`中的`SingleThreadEventExecutor.this即NioEventLoop`

,具体的run()方法如下：

```java
 /**
     * 核心方法：I/O数据的读取
     * 1、首先看有没有未执行的任务，有的话直接执行，否则就去轮训看是否有就绪的Channel
     */
    @Override
    protected void run() {
        for (;;) {
            try {
                try {
                    //-------------switch方法开始-------------------
                    switch (selectStrategy.calculateStrategy(
                                                            selectNowSupplier,  // selector.selectNow()
                                                            hasTasks()          //判断任务队列是否有任务可以执行
                    )) {
                        // 默认实现下，不存在这个情况。要么大于0，要么-1
                    case SelectStrategy.CONTINUE:
                        continue;
                        // 默认实现下，不存在这个情况。要么大于0，要么-1
                    case SelectStrategy.BUSY_WAIT:
                        // fall-through to SELECT since the busy-wait is not supported with NIO

                    case SelectStrategy.SELECT:
                        // 核心方法：Selector进行I/O任务查询：(会阻塞)
                        select(
                                //重置 wakenUp 标记为 false
                                wakenUp.getAndSet(false)
                        );

                        // 'wakenUp.compareAndSet(false, true)' is always evaluated
                        // before calling 'selector.wakeup()' to reduce the wake-up
                        // overhead. (Selector.wakeup() is an expensive operation.)
                        //  'wakenUp.compareAndSet(false, true)'通常被调用是为了减小'selector.wakeup()' 调用开销.
                        //  因为'selector.wakeup()'是一种开锁十分大的操作,所以要有必要调用'selector.wakeup()' 才调用.

                        // However, there is a race condition in this approach.
                        // The race condition is triggered when 'wakenUp' is set to
                        // true too early.
                        // 但是这个方法有一个"竞态条件"将会被触发:被太早的设置为true.
                        // 'wakenUp' is set to true too early if:

                        // 1) Selector is waken up between 'wakenUp.set(false)' and
                        //    'selector.select(...)'. (BAD)
                        // 2) Selector is waken up between 'selector.select(...)' and
                        //    'if (wakenUp.get()) { ... }'. (OK)
                        //
                        // In the first case, 'wakenUp' is set to true and the
                        // following 'selector.select(...)' will wake up immediately.
                        // Until 'wakenUp' is set to false again in the next round,
                        // 'wakenUp.compareAndSet(false, true)' will fail, and therefore
                        // any attempt to wake up the Selector will fail, too, causing
                        // the following 'selector.select(...)' call to block
                        // unnecessarily.
                        //
                        // To fix this problem, we wake up the selector again if wakenUp
                        // is true immediately after selector.select(...).
                        // It is inefficient in that it wakes up the selector for both
                        // the first case (BAD - wake-up required) and the second case
                        // (OK - no wake-up required).
                        // 唤醒。原因：上面select()已经有返回，表示有任务。
                        if (wakenUp.get()) {
                            // 唤醒 JDK selector
                            selector.wakeup();
                        }
                        // fall through
                    default:
                    }
                } catch (IOException e) {
                    // If we receive an IOException here its because the Selector is messed up. Let's rebuild
                    // the selector and retry. https://github.com/netty/netty/issues/8566
                    // 重建selector。
                    rebuildSelector0();
                    handleLoopException(e);
                    continue;
                }
                //-------------switch方法结束-----------------------------
                //NioEventLoop cancel 方法
                cancelledKeys = 0;
                needsToSelectAgain = false;
                final int ioRatio = this.ioRatio;
                if (ioRatio == 100) {//默认为50,通常为false
                    try {
                        //核心方法： 处理 Channel 感兴趣的就绪 IO 事件
                        processSelectedKeys();
                    } finally {
                        // Ensure we always run tasks.
                        // 放在finally，保证运行所有普通任务和定时任务，不限制时间
                        runAllTasks();
                    }
                } else {
                    final long ioStartTime = System.nanoTime();
                    try {
                        // 处理 Channel 感兴趣的就绪 IO 事件
                        processSelectedKeys();
                    } finally {
                        // Ensure we always run tasks.
                        // 处理 Channel 感兴趣的就绪 IO 事件
                        final long ioTime = System.nanoTime() - ioStartTime;
                        runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
                    }
                }
            } catch (Throwable t) {
                handleLoopException(t);
            }
            // Always handle shutdown even if the loop processing threw an exception.
            // EventLoop 优雅关闭
            // 当netty服务器停止时，一般会调用 NioEventloopGroup.shutdownGracefully(),此方法会更改相应该的标记位
            // 然后每个NioEventloop的run()方法中，会检查此标识来达到优雅停机机目的。
            try {
                if (isShuttingDown()) {// 检测线程状态,如果正在停机
                    // 关闭注册的channel
                    closeAll();
                    //如果已经确定成功关闭
                    if (confirmShutdown()) {
                        return;
                    }
                }
            } catch (Throwable t) {
                handleLoopException(t);
            }
        }
    }
```

> 结论：
>
> 最终是通过具体的干活线程NioEventLoop中的run()方法中的for(;;)死循环来实现Selector相关监听。
>
> 监听到相关的事件后，再派发给相应的ChannelPipeline进行相关处理。

## 二、启动栈信息

```verilog
      
	 ------------第三部分：异步线程监听端口，其中最后一步ServerSocketChannelImpl是JDK原生 ------
      bind:212, ServerSocketChannelImpl (sun.nio.ch)
      doBind:138, NioServerSocketChannel (io.netty.channel.socket.nio)
      bind:598, AbstractChannel$AbstractUnsafe (io.netty.channel)
      bind:1390, DefaultChannelPipeline$HeadContext (io.netty.channel)
      invokeBind:521, AbstractChannelHandlerContext (io.netty.channel)
      bind:501, AbstractChannelHandlerContext (io.netty.channel)
      bind:198, LoggingHandler (io.netty.handler.logging)
      invokeBind:521, AbstractChannelHandlerContext (io.netty.channel)
      bind:501, AbstractChannelHandlerContext (io.netty.channel)
      bind:1036, DefaultChannelPipeline (io.netty.channel)
      bind:277, AbstractChannel (io.netty.channel)
      run:443, AbstractBootstrap$2 (io.netty.bootstrap)
      safeExecute$$$capture:163, AbstractEventExecutor (io.netty.util.concurrent)
      safeExecute:-1, AbstractEventExecutor (io.netty.util.concurrent)
       - Async stacktrace

      -------------第二部分：异步线程：------------------------------------------------------
      addTask:-1, SingleThreadEventExecutor (io.netty.util.concurrent)
      execute:755, SingleThreadEventExecutor (io.netty.util.concurrent)
      doBind0:438, AbstractBootstrap (io.netty.bootstrap)
      access$000:58, AbstractBootstrap (io.netty.bootstrap)
      operationComplete:359, AbstractBootstrap$1 (io.netty.bootstrap)
      operationComplete:343, AbstractBootstrap$1 (io.netty.bootstrap)
      notifyListener0:501, DefaultPromise (io.netty.util.concurrent)
      notifyListenersNow:475, DefaultPromise (io.netty.util.concurrent)
      notifyListeners:414, DefaultPromise (io.netty.util.concurrent)
      setValue0:539, DefaultPromise (io.netty.util.concurrent)
      setSuccess0:528, DefaultPromise (io.netty.util.concurrent)
      trySuccess:99, DefaultPromise (io.netty.util.concurrent)
      trySuccess:84, DefaultChannelPromise (io.netty.channel)
      safeSetSuccess:1029, AbstractChannel$AbstractUnsafe (io.netty.channel)
      register0:546, AbstractChannel$AbstractUnsafe (io.netty.channel)
      access$200:446, AbstractChannel$AbstractUnsafe (io.netty.channel)
      run:511, AbstractChannel$AbstractUnsafe$1 (io.netty.channel)
      safeExecute$$$capture:163, AbstractEventExecutor (io.netty.util.concurrent)
      safeExecute:-1, AbstractEventExecutor (io.netty.util.concurrent)
       - Async stacktrace
     ------------第一部分： 同步线程，从EchoServer启动到SingleThreadEventExecutor-------------
      addTask:-1, SingleThreadEventExecutor (io.netty.util.concurrent)
      execute:755, SingleThreadEventExecutor (io.netty.util.concurrent)
      register:508, AbstractChannel$AbstractUnsafe (io.netty.channel)
      register:91, SingleThreadEventLoop (io.netty.channel)
      register:79, SingleThreadEventLoop (io.netty.channel)
      register:95, MultithreadEventLoopGroup (io.netty.channel)
      initAndRegister:392, AbstractBootstrap (io.netty.bootstrap)
      doBind:324, AbstractBootstrap (io.netty.bootstrap)
      bind:312, AbstractBootstrap (io.netty.bootstrap)
      bind:288, AbstractBootstrap (io.netty.bootstrap)
      main:95, EchoServer (io.netty.example.echo)
```

## 三、接受连接时栈信息

```verilog
        initChannel:84, EchoServer$1 (io.netty.example.echo)
        initChannel:81, EchoServer$1 (io.netty.example.echo)
        initChannel:152, ChannelInitializer (io.netty.channel)
        handlerAdded:128, ChannelInitializer (io.netty.channel)
        callHandlerAdded:994, AbstractChannelHandlerContext (io.netty.channel)
        callHandlerAdded0:656, DefaultChannelPipeline (io.netty.channel)
        access$100:47, DefaultChannelPipeline (io.netty.channel)
        execute:1545, DefaultChannelPipeline$PendingHandlerAddedTask (io.netty.channel)
        callHandlerAddedForAllHandlers:1187, DefaultChannelPipeline (io.netty.channel)
        invokeHandlerAddedIfNeeded:697, DefaultChannelPipeline (io.netty.channel)
        register0:601, AbstractChannel$AbstractUnsafe (io.netty.channel)
        access$200:500, AbstractChannel$AbstractUnsafe (io.netty.channel)
        run:568, AbstractChannel$AbstractUnsafe$1 (io.netty.channel)
        safeExecute$$$capture:163, AbstractEventExecutor (io.netty.util.concurrent)
        safeExecute:-1, AbstractEventExecutor (io.netty.util.concurrent)
         - Async stacktrace
----------------接受连接-------------------------
        addTask:-1, SingleThreadEventExecutor (io.netty.util.concurrent)
        execute:755, SingleThreadEventExecutor (io.netty.util.concurrent)
        register:565, AbstractChannel$AbstractUnsafe (io.netty.channel)
        register:91, SingleThreadEventLoop (io.netty.channel)
        register:79, SingleThreadEventLoop (io.netty.channel)
        register:96, MultithreadEventLoopGroup (io.netty.channel)
        channelRead:307, ServerBootstrap$ServerBootstrapAcceptor (io.netty.bootstrap)
        invokeChannelRead:379, AbstractChannelHandlerContext (io.netty.channel)
        invokeChannelRead:361, AbstractChannelHandlerContext (io.netty.channel)
        fireChannelRead:353, AbstractChannelHandlerContext (io.netty.channel)
        channelRead:248, LoggingHandler (io.netty.handler.logging)
        invokeChannelRead:379, AbstractChannelHandlerContext (io.netty.channel)
        invokeChannelRead:361, AbstractChannelHandlerContext (io.netty.channel)
        fireChannelRead:353, AbstractChannelHandlerContext (io.netty.channel)
        channelRead:1489, DefaultChannelPipeline$HeadContext (io.netty.channel)
        invokeChannelRead:379, AbstractChannelHandlerContext (io.netty.channel)
        invokeChannelRead:361, AbstractChannelHandlerContext (io.netty.channel)
        fireChannelRead:976, DefaultChannelPipeline (io.netty.channel)
        read:93, AbstractNioMessageChannel$NioMessageUnsafe (io.netty.channel.nio)
        processSelectedKey:845, NioEventLoop (io.netty.channel.nio)
        processSelectedKeysOptimized:765, NioEventLoop (io.netty.channel.nio)
        processSelectedKeys:666, NioEventLoop (io.netty.channel.nio)
        run:611, NioEventLoop (io.netty.channel.nio)
        run:907, SingleThreadEventExecutor$5 (io.netty.util.concurrent)
        run:74, ThreadExecutorMap$2 (io.netty.util.internal)
        run:30, FastThreadLocalRunnable (io.netty.util.concurrent)
        run:745, Thread (java.lang)
```

